Two Sided Marketplace Course from Codeplace, on Rails 5

1
gem install rails
rails -v // 5.02

2
rails new estuk // estuk/ folder created, 
    how to run rails 5 on c9.io?

3
cd estuk; rails server -b $IP -p $PORT; 
    it's running, how to get to it?
click on 'Share' next to gear in c9 workspace, copy the 2nd link, paste in new tab and run

4
SAVE FIRST COMMIT: 
    git init; git add --all; git commit; (not passing -m will open the nano editor to add the commit message)
    type the commit message
    CTRL O; [ENTER]; CTRL X (save the message; confirm command; exit nano editor)
    
5
ADD REMOTE REPOSITORY:
    In github, click new repository, give it a good name and description, then:
    git remote add origin https://github.com/ImsirovicAjdin/codeplace-two.git
    git push -u origin master
6
ADD BOOTSTRAP
sourcecode: 
    https://github.com/seyhunak/twitter-bootstrap-rails
add bootstrap gem: 
    gem 'twitter-bootstrap-rails', :git => 'git://github.com/seyhunak/twitter-bootstrap-rails.git'
run bundle install: 
    bundle install
run the generator:
    rails generate bootstrap:install static
git commit:
    git add --all; git commit -m "Add bootstrap"; git push -u origin master
    
7
INSTALL SIMPLEFORM
source:
    https://github.com/plataformatec/simple_form
add simple_form gem:
    gem 'simple_form'
run the following command to install it:
    bundle install
Run the generator:
    rails generate simple_form:install --bootstrap
git commit:
    git add --all; git commit -m "Add simple_form"; git push -u origin master
    
8 
ADD OUR HOMEPAGE
"Before adding the user Authentication, it's a good idea to have at least one page in our application"
"Generate a controller called 'pages', with only one action -> 'home'
    rails generate controller pages home
"Replace the default route that was generated by the controller and replace it with the following root route":
    Rails.application.routes.draw do
        get 'pages/home'
        root 'pages#home # <-- THIS HERE!

9
TRY REFRESHING THE WEBSITE, YOU'LL GET THIS ERROR:
couldn't find file 'twitter-bootstrap-static/bootstrap' with type 'text/css'
FIX: Restart the server

10
ADD USERS
"We are going to use a really amazing gem for user authentication called: devise."
source:
    https://github.com/plataformatec/devise
add gem:
    gem 'devise'
install the gem:
    bundle install
run the generator for devise, as per the instructions from the documentation:
    rails generate devise:install
To finish up the devise installation, we need to setup the default mailer as per instructions on the terminal output.
    config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
Create the views for the users:
    rails generate devise:views
Finally create the users by runnign the devise generator in the terminal:
    rails generate devise User
After the creation of the User table, migrate the db:
    rake db:migrate
Go to your website/users/sign_up (NOTE: YOU MUST RESTART THE SERVER)
git add --all; git commit -m "Add devise"; git push -u origin master

11
ADD THE HEADER
Bootstrap navbar section:
    http://getbootstrap.com/components/#navbar
Copy the html, add it to _header.html.erb.
    app/views/layouts/_header.html.erb
Render the partial by adding it to application.html.erb:
    just above the yield stmt, inside the body tags
Go to your webpage, F12, remove redundant elements.
    when you done, copy the remaining navbar into _header.
git add --all; git commit -m "Add blank navbar"; git push -u origin master

12
ADD THE DYNAMIC LINKS
Based on whether or not the user is logged in, add the dynamic links to the navbar.

13
ADD THE JUMBOTRON
Navigate and copy:
    http://getbootstrap.com/components/#jumbotron
Add it to homepage:
    ./app/views/pages/home.html.erb
git add --all; git commit -m "Add jumbotron"; git push -u origin master

14
MAKE DEVISE VIEWS LOOK NICER
Create a stylesheet named devise.css.scss:
    ./app/assets/stylestheets/devise.css.scss
Apply the created classes to your sign_in form:
    .app/views/devise/sessions/new.html.erb
The same for the sign_up form:
    ./app/views/devise/registrations/new.html.erb
The same for the reset_password form:
    ./app/views/devise/passwords/new.html.erb
The same for the edit/registrations page:
    ./app/views/devise/registrations/edit.html.erb
Activate client side validation on the simple_form initializer:
    ./app/config/initializers/simple_form.rb
git add --all; git commit -m "Make devise look better"; git push origin master

15
GENERATING BOOKS

With one command we can create the whole book scaffold, it's gonna generate all.
First we gonna think what kind of attributes a book will have:
    name, author name, description, 2 attachments, 1 preview and 1 resource, & price.
We're gonna use stripe, and stripe uses a price in cents. $1 = 100 cents.
SCAFFOLD THE BOOK, start with basic attribs, l8tr we'll add more fields
    rails generate scaffold book name:string author:string description:text price:integer availability:boolean
BEFORE RUNNING THE MIGRATION, SET availability FIELD DEFAULT VALUE TO TRUE
    ./db/migrate/...create_books.rb
        t.boolean :availability, default: true
INSIDE views/books, DELETE index.json.builder and show.json.builder (we don't need these files)
NOW MIGRATE THE DB, this command will create a table named "Books" with 5 columns: name, author, description, price, availability
    rake db:migrate
THE SCAFFOLD CREATED A CSS FILE WE DON'T NEED, DELETE IT
    (X) scaffold.scss
ADD THE books_path TO OUR VIEWS in _header
    ./app/views/layouts/_header.html.erb
ADD THE books_path TO HOMEPAGE TOO
    <% link_to "Books", books_path, class: "btn btn-primary" %>
IN OUR pages_controller, ENSURE THE current_user IS REDIRECTED TO THE books_path
GIT ADD, COMMIT "Add the books scaffold", PUSH

16
CUSTOMIZING THE BOOK SHOW
The target is to customize the way a book looks

CREATE A NEW BOOK
    website/books/new # 'add the book'
REMOVE THE GENERATED HTML FOR THE BOOKS SHOW PAGE
    ./app/views/books/show.html.erb
AND REPLACE IT WITH 2 BOOTSTRAP COLUMNS
    .container>.row>.col-md-6+.col-md-6
COPY AN IMG FILE, PLACE IT AS "book.jpg" in app/assets/images
ON THE 1st COL, MAKE image_tag FOR THE BOOK COVER
    ./app/views/books/show.html.erb
ON THE 2nd COL, DISPLAY ALL THE BOOK'S ATTRIBUTES
GIT ADD, COMMIT "Make Show book page look better", PUSH

17
IMPROVING THE BOOKS INDEX
Target: Improve index page using a partial.

DELETE ALL BOOK INDEX PAGE CONTENT
    ./app/views/books/index.html.erb
ADD BOOTSTRAP-READY CODE in ./app/views/books/index.html.erb
    .row>.col-md-3>.thumbnail...
OPEN THE BOOKS PAGE
    website/books
ADD THE BOOKS ATTRIBUTES TO THE THUMBNAIL CAPTION
    test it with dummy content first
MAKE THE CONTENT DYNAMIC (PULL FROM DB)
    add book partial: "_book.html.erb" in app/views/books
RENDER THE PARTIAL FROM ./app/views/books/index.html.erb
    .row><% render @books %>
NOTE:
    Rails knows, that a partial corresponds to a collection. So you could use render @users, if there is a _user partial, or render @tasks with the corresponding _task partial, and rails with automatically render the partial for each book/task/user in the books/tasks/users variable.
    
On the books_controller, the index action, the @books variable holds the collection of all books. 
Now update the _book.html.erb partial with the properties of the book.
      <p><strong><%= book.name %></strong></p>
      <p><%= book.price.to_f / 100 %></p>
We want to image to be 'clickable' and point to that book, so let's update the partial once more.
    - Make a link_to block containing all the image element, so everything inside the block will link to the book_path.
    - And add a link_to statement to the title of the book to.
Add an extra book, just to check if everything works fine.
    Before you save it, uncheck the available checkbox, to state the book is unavailable.
    the second book is still showing up, while the state of the book is unavailable. Let's fix this.
To fix the index page, and have it showing only the available books, we are going to change the index action in the BooksController.
Open the BooksController, and look for the index action, there you see that the @books variable holds all the Book(s) because of Book.all.
    CHANGE IT TO Book.where(availability: true)
Perfect! 
Now go to your localhost:3000/books  and notice that only the books available are shown in the index page!

GIT ADD, COMMIT "Make the Books index design look better", PUSH

18
IMPROVING THE BOOKS NEW AND EDIT
localhost:3000/books/new, we want to redesign this form
(A) Both the NEW and the EDIT action render the same form from within their views.
Open up the books/edit page, and the books/new page to check it out. 
So if we want to edit the design for these pages, we have to edit the _form.html.erb partial that is rendered in these pages.
(B) Now open up the books/_form.html.erb partial, to add classes and make it look and work better. We are also going to add 'validations' to the input fields.
        ./app/views/books/_form.html.erb
    Inspect the current changes to the form at localhost:3000/books/new
(C)  It already looks much better, but we can do a bit more. 
- Remove the surrounding <div> with the class of 'from-inputs'.
- Add a <br> line below the description to add some space between the price and description. 
- Add a <div> around the availability checkbox  with the bootstrap classes: 'checkbox' and 'text-center'.
- Remove the label from the checkbox, by adding the 'label: false' statement, and put the required validation label to false. 
(D) As a finishing touch, open up the books/new and books/edit views again, and add a text-center class to the h1 title.
        ./app/views/books/new.html.erb
GIT ADD, COMMIT "Make the New and Edit view look better", PUSH

19
ADDING BOOKS USER ASSOCIATION
(TARGET): Before we can make our dashboard, we need to make sure that books are related to users.
We are going to create the relation between the Books with a User. 
This means we are making associations, in our case we could say it in plain English.
"A user owns a book, and a book belongs to a user." 
(A): Let's start by making a migration by running the migration command, and add a user_id to the Books table. 
    rails generate migration AddUserIdToBooks user_id:integer
(B): It's good practice to open up the migration file and inspect if everything is as we wanted.
    ./app/db/migrate/......_...._add_user_id_to_books.rb
(C): If everything looks fine, we can run the migration.
    rake db:migrate
(D): Next we need to modify the User.rb model. Recall that we could say "A user owns a book"? 
In our case, a user can even own many books. 
This association is declared as follows:
    has_many :books
(E): And of course, the Book.rb needs to be updated as well. 
The book belongs to a User, so let's add this relationship to the Books model.
    ./app/models/book.rb
        class Book < ActiveRecord::Base
            belongs_to :user
        end
(F): Now we need to modify the way a book is created, to be sure that the book created is made by the user that is currently logged in.
The way to do that, is to open up the BooksController, and look for the create action. 
    ./app/models/controllers/books_controller.rb
      def create
    @book = current_user.books.new(book_params)
(G): To ensure only an authenticated user can use the create action, we are going to use the before_action that comes with the devise gem. 
The before action doesn't need to be on the index action, because non-logged in users should be able to visit the book's index. 
So let's set the before_action only to the new, edit, create, and update actions.
    ./app/controllers/books_controller.rb
        # Ensure the user is logged in.
        before_action :authenticate_user!, only: [:new, :edit, :create, :update, :destroy]
You can check if this works, by opening an incognito browser window, or clear the current sessions, and then visit the localhost:3000/books/new page. 
GIT ADD, COMMIT "Add book-user association"

20
CREATING THE DASHBOARD
We now have a book-and-user association, so it's time to start managing them. 
Let's do that by adding a dashboard to our application!

(A): In order to arrange the dashboard we need a link in our header to point to the dashboard, but it should be only available for the logged in user. 
Let's add the dashboard action to the PagesController
    ./app/controllers/pages_controller.rb
          def dashboard
            end
(B): Also we need to create a view for our dashboard.
create a new file:   app/views/pages/dashboard.html.erb 
    Just put any text in the view, like "Hello world",  to test it out.

(C): To be able to view the dashboard, we have to configure the route for it.
The way to do this is to open up the routes.rb file, and add the dashboard action to match the get request, and point it to the pages controller with the dashboard action.
    ./app/config/routes.rb
        get 'dashboard' => 'pages#dashboard'  
You should now be able to visit the dashboard, located at the localhost:3000/dashboard

(D): Let's make sure only logged in users can access the dashboard. 
    ./app/controllers/pages_controller.rb
        # make sure users are logged in.
        before_action :authenticate_user!, only: [:dashboard]
(E): This would be a good time to add the dashboard link to our header partial.
Open up the _header.html.erb and also the terminal, because we need to find out which path we should use for the dashboard.
In your terminal, run the rake routes command.
As you see, right at the bottom of the terminal output we can see the that the 'get' action for the dashboard route points to pages#dashboard.
Our link then should be dashboard_path, let's add it to our _header partial, inside of a list item, add a link_to with the title "dashboard" and the path of dashboard_path.
(F): We can now make our dashboard more functional, let's start by removing the "hello world", and add some bootstrap elements to arrange the view. The dashboard will hold 3 columns, one with a table for My Books, one with the books Purchased by that user, and the last would be the books that the current user has Sold. 
We can do that by adding a row, and divide that into 3 x <div> col-md-4. 
Start with a row, add a h1-text-center with the title "Dashboard", and add the 3 columns.
    .row>h1.text-center{Dashboard}+.col-md-4*3
(G): Now add some titles to each column, Books, Purchased, and Sales.
Also, add a button to create a new book in the first column. 
        ./app/views/pages/dashboard.html.erb
Check out your dashboard, and see if all looks fine.
(H): Now, go over to the bootstrap site, and check out the documentation for tables.
For our application, the condensed table would be the best fit.
Open up your browser inspector, and copy the <table class> with all its contents to your dashboard, and paste it right below the h3 tag.
(I): Go back to your browser and check if your table looks anything like the one you copied from the bootstrap pages.
Next, edit the table head <th> and table data <td> to the proper attributes of our book.
We want to have the Id, Name and Availability of the book, and an extra <th> for the actions. Also, we can delete the last two rows since we are not going to use them. 

(J): Now make this dynamic, to do this we need our dashboard to have a variable with our books.
Open the PagesController.
Add a variable to the dashboard, called @books, and let's get all the books for the current_user and pass it to that variable.
        ./app/controllers/pages_controller.rb
            @books = current_user.books
(K): We want all of our books to be on their own table row <tr>, so each book in the books variable should be in its own element. 
Go back to the dashboard page, and open up a block for the @books variable, and pass each attribute to the correspondent table. 
(L): Let's make the book title a link to the book, and add the edit action to the empty last table data column <td>
(M): Go back to the browser and see you new made dashboard!
Finally, add and commit your changes and then push it to GitHub.
COMMENT "Created the dashboard"

21
AUTH USING CANCAN
TARGET:
We are going to use a new concept called authorization, because we have an issue with the way how are edit, update and destroy actions are now designed.
First, start your server, open the browser and create a new User, and with the new User lets's create a New Book. 
Start the server, open your browser and create a New User.
As you're logged in as the second user, create a New book. 
The images will be the same, we are going to handle that later, but for now make sure you have 2 different books, belonging too 2 different users.
When done correctly, we can now go to each book, and if we modify the url in the browser, we can also edit each book.
Try it out, visit each book, and alter the url. 
This should not be possible!
Since we are logged in as the second user, we should not be able to edit any book that we do not own. 
To solve this issue, we are going to make use of an amazing gem by the great Ryan Bates, called: cancan.
Go over to Github and check out the documentation for the CanCan gem.
If you have done so, it's time to add it to our gemfile. 
(A): gem 'cancan'
(B): After saving the gemfile, run the bundle install command.
(C): Now that the CanCan is properly installed we need to run a generator, as explained in the documentation.   This generator will create the Ability Model. 
        rails generate cancan:ability
(D): Open the newly generated Ability.rb model, and look for the line that initializes a User if there is none. 
We want to uncomment this line.
    ./app/models/ability.rb
        user ||= User.new # guest user (not logged in)
(E): The Books controller has several actions, some of them should be only available to the owner of the book. Others, like the index, should also be available for visitors that are not signed in. 
Let's start by making :read available for all visitors.
    ./app/models/ability.rb
        can :read, :all
(F): Next we want only users who own the book to be able to :manage the books.
For this, we create a block that will try and see if the user of the book is the same as the current user. 
        can :manage, Book do |book| 
                book.try(:user) == user 
            end
If we now test this in our browser, you'll notice nothing has changed!
In order to have our ability's implemented we need to specify them in our controller.
(G): Open your BooksController and add the authorize! method to the edit, update, and destroy action to let CanCan handle the authorization.     ./app/controller/books_controller.rb
            (just under the 'def create' and 'def destroy')
Why don't we apply this to the new/create actions? That is because these actions apply when there is not a book yet, so having authorization on these actions would be useless.
Everything looks fine, so it's time to test our application and see if we can edit a book that we don't own.
Restart your server, login as the first user, and visit the second book (belonging to the second user) and visit the edit page for that book.
 restart your server before testing our new functionality!
    SHOULD SEE CANCAN::AccessDenied
Perfect, our authorization works!
The final thing we want to change is the error message we are now getting.
(H): Let's fix that error message, and prevent our visitors from seeing this. 
We are also going to add an notice: "message" statement, that we will use in the next chapter when we add Flash Messages to our app.
But first, open the ApplicationController.rb, and create a rescue statement, that will catch the exceptions that CanCan will throw us, and have the user redirected to the home page. 
As stated, the additional notice: will be used in the next paragraph.
If we now visit the edit page again, we are redirected to the Root off our application!
GIT A, C "Add auth", PUSH

22
FLASH MESSAGES
Now we will add alerts and messages to our application, to notice our users if there is something wrong or just alert every time something important happens. 
Rails has a built-in flash method, that can easily use the Bootstrap #Alert component.
The flash messages will be used in our HTML throughout the entire application, so for that reason we could either use a _partial, but the best way for now is to simply add it to the application.html.erb file. 
So let's open up the application.html.erb file and add our flash messages.
(A): ./app/views/layouts/application.html.erb
		<%= render "layouts/header" %>
	
		<% flash.each do |type, message| %>
		<% end %>
As you can see by the block that we created for the flash method, each flash method comes with 2 attributes. A Type, and the Message itself.  
For this chapter, we are only going to use the message itself, but if you recall from our previous chapter you know that we can easily add the type of notice: or alert: .

(B): Continue with the flash iteration, by adding the bootstrap <div> and classes, and finally the message itself. 
We want the alert to be of the bootstrap type info and have it fade-in. Also, we want to have a button to close it. Luckely bootstrap comes with a great javascript function to close this alert.
        ./app/views/layouts/application.html.erb
(C): Everything is in place, so go over to the browser, and log in or log out to see your new message. 
You can also check to see our exception message from the ApplicationController we made earlier. Try to edit the book from the other user! 
Everything works perfect, so we can now commit our changes and then push it to GitHub.
git commit -m "Added flash Notification"

23
INSTALL IMAGEMAGICK

For this recipe we are going to use the paperclip gem, but before we can use that, we need to install a very important component called: ImageMagick.
Make sure ImageMagick is installed on your machine before you continue to the next step. 
For instructions on how to install it, please use these links for your operating system.
"How to install imagemagick on c9" https://community.c9.io/t/install-imagemagick/3608
        *if !works, start with this ln* sudo add-apt-repository main
        sudo apt-get update
        sudo apt-get install imagemagick

24
INSTALL PAPERCLIP
To add Images and other recourses to our books we are going to use a very awesome gem made by the guys from Thoughbot, called PaperClip.
Head over to the documentation and check it out. https://github.com/thoughtbot/paperclip
After reading the documentation, we are going to add the gem to our gemfile
gem 'paperclip'









